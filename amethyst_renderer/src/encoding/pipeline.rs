use super::properties::EncodedProp;
use amethyst_assets::{Asset, AssetStorage, Handle};
use amethyst_core::specs::{world::Index, VecStorage};
use hibitset::BitSet;
use shred::Resources;

// TODO: use actual shaders
pub struct Shader {
    /// Temporary way to test against hardcoded props
    pub mock_properties: Vec<EncodedProp>,
}

impl Asset for Shader {
    const NAME: &'static str = "Shader";
    type HandleStorage = VecStorage<Handle<Self>>;
    type Data = Self;
}

/// A set of properties used for encoding.
/// Derived from a shader.
pub struct EncoderPipeline {
    properties: Vec<EncodedProp>,
    entities: BitSet,
    entities_count: usize,
    ubo_layout_size: usize,
}

impl EncoderPipeline {}

// note: this should probably be considered a "computed asset"
impl Asset for EncoderPipeline {
    const NAME: &'static str = "EncoderPipeline";
    type HandleStorage = VecStorage<Handle<Self>>;
    type Data = EncoderPipeline;
}

impl EncoderPipeline {
    /// Resolve a pipeline from given shader. This effectively does the lookup
    /// of shader metadata generated by the asset pipeline.
    pub fn from_shader(res: &Resources, shader_handle: &Handle<Shader>) -> Option<Self> {
        let storage = res.fetch::<AssetStorage<Shader>>();
        storage.get(shader_handle).map(|shader| {
            // TODO: Implement proper property extraction from shader
            let props: Vec<EncodedProp> = shader.mock_properties.clone();

            EncoderPipeline {
                ubo_layout_size: props.iter().map(|prop| prop.0.ubo_size()).sum(),
                properties: props,
                entities: BitSet::new(),
                entities_count: 0,
            }
        })
    }

    /// Get BitSet structure that holds associations
    /// of entity IDs to the pipeline.
    pub fn bitset(&self) -> &BitSet {
        &self.entities
    }

    /// Add entity id to the pipeline.
    #[inline]
    pub fn add_id(&mut self, id: Index) {
        if !self.entities.contains(id) {
            unsafe { self.add_id_unchecked(id) }
        }
    }

    /// Add entity id to the pipeline.
    ///
    /// Unsafe because user must ensure that the entity is not already present.
    #[inline]
    pub unsafe fn add_id_unchecked(&mut self, id: Index) {
        self.entities.add(id);
        self.entities_count += 1;
    }

    /// Remove entity id from the pipeline.
    #[inline]
    pub fn remove_id(&mut self, id: Index) {
        if self.entities.contains(id) {
            self.entities.remove(id);
            self.entities_count -= 1;
        }
    }

    /// Remove all associated entities from the pipeline.
    pub fn clear(&mut self) {
        self.entities.clear();
        self.entities_count = 1;
    }
}
