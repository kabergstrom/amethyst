use super::EncodedProp;
use amethyst_assets::{Asset, Handle, ProcessingState, Result};
use amethyst_core::specs::{world::Index, VecStorage};
use hibitset::BitSet;

/// A set of shader properties at specific offsets.
/// The type should guarantee that all properties are non-overlapping.
/// TODO: do the actual validation at creation time.
#[derive(PartialEq, Eq, Hash, Clone, Debug)]
pub struct EncodingLayout {
    /// A list of all properties at specific offset
    pub props: Vec<LayoutProp>,
    /// Total number of bytes required for the structure, including padding
    pub padded_size: u32,
}

impl EncodingLayout {
    /// Extract encoding layout from shader
    pub fn from_shader(shader: &Shader) -> Self {
        // TODO: cheating here, needs a real shader with proper
        // spirv-reflect data to implement that properly
        shader.mock_layout.clone()
    }
}

// note: this should probably be considered a "computed asset"
impl Asset for EncodingLayout {
    const NAME: &'static str = "EncodingLayout";
    type HandleStorage = VecStorage<Handle<Self>>;
    type Data = EncodingLayout;
}
impl Into<Result<ProcessingState<EncodingLayout>>> for EncodingLayout {
    fn into(self) -> Result<ProcessingState<EncodingLayout>> {
        Ok(ProcessingState::Loaded(self))
    }
}

#[derive(PartialEq, Eq, Hash, Clone, Debug)]
pub struct LayoutProp {
    /// Name and type of the property. Determines the encoders to run.
    pub prop: EncodedProp,
    /// Offset in bytes fro mthe start of the layout structure.
    /// Instructs the `BufferWriter` where to put the encoded data.
    pub absolute_offset: u32,
}

impl LayoutProp {
    pub fn ubo_size(&self) -> usize {
        self.prop.0.ubo_size()
    }
}

/// Shader structure placeholder
/// TODO: use actual shaders
pub struct Shader {
    /// Temporary way to test against hardcoded layout
    pub mock_layout: EncodingLayout,
}

impl Asset for Shader {
    const NAME: &'static str = "Shader";
    type HandleStorage = VecStorage<Handle<Self>>;
    type Data = Self;
}
impl Into<Result<ProcessingState<Shader>>> for Shader {
    fn into(self) -> Result<ProcessingState<Shader>> {
        Ok(ProcessingState::Loaded(self))
    }
}

/// A set of properties used for encoding.
/// Derived from a shader.
#[derive(Debug)]
pub struct EncoderPipeline {
    layout: EncodingLayout,
    entities: BitSet,
    entities_count: usize,
}

impl EncoderPipeline {
    /// Resolve a pipeline from given shader. This effectively does the lookup
    /// of shader metadata generated by the asset pipeline.
    pub fn with_layout(layout: EncodingLayout) -> Self {
        EncoderPipeline {
            layout: layout.clone(),
            entities: BitSet::new(),
            entities_count: 0,
        }
    }

    /// Retreive the encoding layout
    pub fn layout(&self) -> &EncodingLayout {
        &self.layout
    }

    /// Retreive the combined size in bytes of whole uniform buffer written in the pipeline encoding
    pub fn ubo_size(&self) -> usize {
        (self.layout.padded_size as usize) * self.entities_count
    }

    /// Get BitSet structure that holds associations
    /// of entity IDs to the pipeline.
    pub fn bitset(&self) -> &BitSet {
        &self.entities
    }

    /// Add entity id to the pipeline.
    #[inline]
    pub fn add_id(&mut self, id: Index) {
        if !self.entities.contains(id) {
            unsafe { self.add_id_unchecked(id) }
        }
    }

    /// Add entity id to the pipeline.
    ///
    /// Unsafe because user must ensure that the entity is not already present.
    #[inline]
    pub unsafe fn add_id_unchecked(&mut self, id: Index) {
        self.entities.add(id);
        self.entities_count += 1;
    }

    /// Remove entity id from the pipeline.
    #[inline]
    pub fn remove_id(&mut self, id: Index) {
        if self.entities.contains(id) {
            self.entities.remove(id);
            self.entities_count -= 1;
        }
    }

    /// Remove all associated entities from the pipeline.
    pub fn clear(&mut self) {
        self.entities.clear();
        self.entities_count = 1;
    }
}
