use std::{
    sync::Arc, io::Read,
};
use ::uuid;

use amethyst_core::specs::storage::UnprotectedStorage;

#[cfg(feature = "profiler")]
use thread_profiler::profile_scope;

use serde::{Serialize, Deserialize};
use atelier_importer::{SerdeObj, ImporterValue, ImportedAsset, Importer};
pub use atelier_importer as importer;
use serde_dyn::{uuid, TypeUuid};

use crate::{ErrorKind, Handle, Result, ResultExt, Source};


/// One of the three core traits of this crate.
///
/// You want to implement this for every type of asset like
///
/// * `Mesh`
/// * `Texture`
/// * `Terrain`
///
/// and so on. Now, an asset may be available in different formats.
/// That's why we have the `Data` associated type here. You can specify
/// an intermediate format here, like the vertex data for a mesh or the samples
/// for audio data.
///
/// This data is then generated by the `Format` trait.
pub trait Asset: Send + Sync + 'static {
    /// An identifier for this asset used for debugging.
    fn name() -> &'static str;

    /// The `Data` type the asset can be created from.
    type Data: Send + Sync + 'static;

    /// The ECS storage type to be used. You'll want to use `VecStorage` in most cases.
    type HandleStorage: UnprotectedStorage<Handle<Self>> + Send + Sync;
}

/// AssetUUID is a globally unique identifier used to reference an asset
/// Generated by the Asset Pipeline when the asset is imported.
pub type AssetUUID = uuid::Uuid;

/// A format, providing a conversion from bytes to asset data, which is then
/// in turn accepted by `Asset::from_data`. Examples for formats are
/// `Png`, `Obj` and `Wave`.
pub trait Format<A: Asset>: Send + 'static {
    /// A unique identifier for this format.
    fn name() -> &'static str where Self: Sized;
    
    /// Options specific to the format, which are passed to `import`.
    /// E.g. for textures this would be stuff like mipmap levels and
    /// sampler info.
    type Options: Send + 'static;

    /// Reads the given bytes and produces asset data.
    ///
    /// ## Reload
    ///
    /// The reload structure has metadata which allows the asset management
    /// to reload assets if necessary (for hot reloading).
    /// You should only create this if `create_reload` is `true`.
    /// Also, the parameter is just a request, which means you can also return `None`.
    fn import(
        &self,
        name: String,
        source: Arc<dyn Source>,
        options: Self::Options,
        create_reload: bool,
    ) -> Result<FormatValue<A>>;
}

/// The `Ok` return value of `Format::import` for a given asset type `A`.
pub struct FormatValue<A: Asset> {
    /// The format data.
    pub data: A::Data,
}

impl<A: Asset> FormatValue<A> {
    /// Creates a `FormatValue` from only the data (setting `reload` to `None`).
    pub fn data(data: A::Data) -> Self {
        FormatValue { data }
    }
}

/// This is a simplified version of `Format`, which doesn't give you as much freedom,
/// but in return is simpler to implement.
/// All `SimpleFormat` types automatically implement `Format`.
/// This format assumes that the asset name is the full path and the asset is only
/// contained in one file.
pub trait SimpleFormat<A: Asset> {
    /// A unique identifier for this format.
    fn name() -> &'static str where Self:Sized { "NONE" } 
    /// Options specific to the format, which are passed to `import`.
    /// E.g. for textures this would be stuff like mipmap levels and
    /// sampler info.
    type Options: Clone + Send + Sync + 'static;

    /// Produces asset data from given bytes.
    fn import(&self, bytes: Vec<u8>, options: Self::Options) -> Result<A::Data>;
}

impl<A, T> Format<A> for T
where
    A: Asset,
    T: SimpleFormat<A> + Clone + Send + Sync + 'static,
{
    fn name() -> &'static str { T::name() }
    type Options = T::Options;

    fn import(
        &self,
        name: String,
        source: Arc<dyn Source>,
        options: Self::Options,
        create_reload: bool,
    ) -> Result<FormatValue<A>> {
        #[cfg(feature = "profiler")]
        profile_scope!("import_asset");
        if create_reload {
            let (b, m) = source
                .load_with_metadata(&name)
                .chain_err(|| ErrorKind::Source)?;
            let data = T::import(&self, b, options.clone())?;
            Ok(FormatValue { data })
        } else {
            let b = source.load(&name).chain_err(|| ErrorKind::Source)?;
            let data = T::import(&self, b, options)?;

            Ok(FormatValue::data(data))
        }
    }
}

/// A simple state for Importer to retain the same UUID between imports
/// for all single-asset source files
#[derive(Default, Serialize, Deserialize)]
pub struct SimpleImporterState {
    id: Option<AssetUUID>,
}
uuid! { SimpleImporterState => 276663539928909366810068622540168088635 }

/// Wrapper struct to be able to impl Importer for any SimpleFormat
pub struct SimpleImporter<A: Asset, T: SimpleFormat<A> + TypeUuid>(pub T, ::std::marker::PhantomData<A>);

impl<A: Asset, T: SimpleFormat<A> + TypeUuid + 'static> From<T> for SimpleImporter<A, T> {
    fn from(fmt: T) -> SimpleImporter<A, T> {
        SimpleImporter(fmt, ::std::marker::PhantomData)
    }
}
impl<A: Asset, T: SimpleFormat<A> + TypeUuid + Send + 'static> TypeUuid for SimpleImporter<A, T>
where
    <A as Asset>::Data: SerdeObj, 
{
    const UUID: u128 = T::UUID;
}

impl<A: Asset, T: SimpleFormat<A> + TypeUuid + Send + 'static> Importer for SimpleImporter<A, T>
where
    <A as Asset>::Data: SerdeObj,
{
    type State = SimpleImporterState;
    type Options = T::Options;

    fn version_static() -> u32
    where
        Self: Sized,
    {
        1
    }
    fn version(&self) -> u32 {
        Self::version_static()
    }

    fn import(
        &self,
        source: &mut dyn Read,
        options: Self::Options,
        state: &mut Self::State,
    ) -> importer::Result<ImporterValue> {
        if state.id.is_none() {
            state.id = Some(uuid::Uuid::new_v4());
        }
        let mut bytes = Vec::new();
        source.read_to_end(&mut bytes)?;
        let import_result = self.0.import(bytes, options).map_err(|e| importer::Error::Boxed(Box::new(e)))?;
        Ok(ImporterValue {
            assets: vec![ImportedAsset {
                id: state.id.expect("AssetUUID not generated"),
                search_tags: Vec::new(),
                build_deps: Vec::new(),
                load_deps: Vec::new(),
                instantiate_deps: Vec::new(),
                asset_data: Box::new(import_result),
                build_pipeline: None,
            }],
        })
    }
}


#[macro_export]
macro_rules! simple_importer {
    ($($ext:expr => $type:expr),*,) => {
        $crate::simple_importer! {
            $(
                $ext => $type
            ),*
        }
    };
    ($($ext:expr => $type:expr),*) => {
        mod _simple_importer_mod {
            use $crate::inventory;
            use $crate::importer;
            use $crate::SimpleImporter;
            use super::*;
            $(
                inventory::submit! {
                    importer::SourceFileImporter {
                        extension: $ext,
                        instantiator: || Box::new(SimpleImporter::from($type)),
                    }
                }
            )*
        }
    }
}